import{Z as P,$ as x}from"./index.js";import{E}from"./Reports.js";import"./Breadcrumb.js";import"./chevron-right.js";import"./select.js";import"./index10.js";import"./index4.js";import"./index11.js";import"./index9.js";import"./index5.js";import"./index7.js";import"./index8.js";import"./index12.js";import"./chevron-down.js";import"./table.js";import"./index14.js";import"./usePagination.js";import"./react-icons.esm.js";import"./badge.js";import"./tooltip.js";import"./index6.js";import"./alert.js";import"./skeleton.js";import"./MemberLedgerReportcolumn.js";import"./format.js";import"./ChooseMemberPopoverCommand.js";import"./popover.js";import"./command.js";import"./index3.js";import"./dialog.js";import"./search.js";import"./chevrons-up-down.js";import"./checkbox.js";import"./jspdf.plugin.autotable.js";import"./label.js";import"./input.js";import"./calendar2.js";import"./chevron-left.js";import"./calendar.js";import"./switch.js";function g(m){const e=m.split("/").filter(t=>t!=="."),r=[];return e.forEach(t=>{t===".."&&r.length>0&&r[r.length-1]!==".."?r.pop():r.push(t)}),r.join("/")}function R(m,e){m=g(m),e=g(e);const r=m.split("/"),t=e.split("/");return m!==e&&r.every((i,n)=>i===t[n])}class b extends P{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async e=>{var r,t;const i=x(e,e.webFetchExtra),n=await fetch(e.url,i);let o;if(!e.progress)o=await n.blob();else if(!(n!=null&&n.body))o=new Blob;else{const c=n.body.getReader();let a=0;const d=[],h=n.headers.get("content-type"),f=parseInt(n.headers.get("content-length")||"0",10);for(;;){const{done:p,value:y}=await c.read();if(p)break;d.push(y),a+=(y==null?void 0:y.length)||0;const w={url:e.url,bytes:a,contentLength:f};this.notifyListeners("progress",w)}const u=new Uint8Array(a);let l=0;for(const p of d)typeof p>"u"||(u.set(p,l),l+=p.length);o=new Blob([u.buffer],{type:h||void 0})}return{path:(await this.writeFile({path:e.path,directory:(r=e.directory)!==null&&r!==void 0?r:void 0,recursive:(t=e.recursive)!==null&&t!==void 0?t:!1,data:o})).uri,blob:o}}}readFileInChunks(e,r){throw this.unavailable("Method not implemented.")}async initDb(){if(this._db!==void 0)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((e,r)=>{const t=indexedDB.open(this.DB_NAME,this.DB_VERSION);t.onupgradeneeded=b.doUpgrade,t.onsuccess=()=>{this._db=t.result,e(t.result)},t.onerror=()=>r(t.error),t.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(e){const t=e.target.result;switch(e.oldVersion){case 0:case 1:default:t.objectStoreNames.contains("FileStorage")&&t.deleteObjectStore("FileStorage"),t.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}}async dbRequest(e,r){const t=this._writeCmds.indexOf(e)!==-1?"readwrite":"readonly";return this.initDb().then(i=>new Promise((n,o)=>{const a=i.transaction(["FileStorage"],t).objectStore("FileStorage")[e](...r);a.onsuccess=()=>n(a.result),a.onerror=()=>o(a.error)}))}async dbIndexRequest(e,r,t){const i=this._writeCmds.indexOf(r)!==-1?"readwrite":"readonly";return this.initDb().then(n=>new Promise((o,s)=>{const h=n.transaction(["FileStorage"],i).objectStore("FileStorage").index(e)[r](...t);h.onsuccess=()=>o(h.result),h.onerror=()=>s(h.error)}))}getPath(e,r){const t=r!==void 0?r.replace(/^[/]+|[/]+$/g,""):"";let i="";return e!==void 0&&(i+="/"+e),r!==""&&(i+="/"+t),i}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(e){const r=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[r]);if(t===void 0)throw Error("File does not exist.");return{data:t.content?t.content:""}}async writeFile(e){const r=this.getPath(e.directory,e.path);let t=e.data;const i=e.encoding,n=e.recursive,o=await this.dbRequest("get",[r]);if(o&&o.type==="directory")throw Error("The supplied path is a directory.");const s=r.substr(0,r.lastIndexOf("/"));if(await this.dbRequest("get",[s])===void 0){const h=s.indexOf("/",1);if(h!==-1){const f=s.substr(h);await this.mkdir({path:f,directory:e.directory,recursive:n})}}if(!i&&!(t instanceof Blob)&&(t=t.indexOf(",")>=0?t.split(",")[1]:t,!this.isBase64String(t)))throw Error("The supplied data is not valid base64 content.");const a=Date.now(),d={path:r,folder:s,type:"file",size:t instanceof Blob?t.size:t.length,ctime:a,mtime:a,content:t};return await this.dbRequest("put",[d]),{uri:d.path}}async appendFile(e){const r=this.getPath(e.directory,e.path);let t=e.data;const i=e.encoding,n=r.substr(0,r.lastIndexOf("/")),o=Date.now();let s=o;const c=await this.dbRequest("get",[r]);if(c&&c.type==="directory")throw Error("The supplied path is a directory.");if(await this.dbRequest("get",[n])===void 0){const h=n.indexOf("/",1);if(h!==-1){const f=n.substr(h);await this.mkdir({path:f,directory:e.directory,recursive:!0})}}if(!i&&!this.isBase64String(t))throw Error("The supplied data is not valid base64 content.");if(c!==void 0){if(c.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");c.content!==void 0&&!i?t=btoa(atob(c.content)+atob(t)):t=c.content+t,s=c.ctime}const d={path:r,folder:n,type:"file",size:t.length,ctime:s,mtime:o,content:t};await this.dbRequest("put",[d])}async deleteFile(e){const r=this.getPath(e.directory,e.path);if(await this.dbRequest("get",[r])===void 0)throw Error("File does not exist.");if((await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(r)])).length!==0)throw Error("Folder is not empty.");await this.dbRequest("delete",[r])}async mkdir(e){const r=this.getPath(e.directory,e.path),t=e.recursive,i=r.substr(0,r.lastIndexOf("/")),n=(r.match(/\//g)||[]).length,o=await this.dbRequest("get",[i]),s=await this.dbRequest("get",[r]);if(n===1)throw Error("Cannot create Root directory");if(s!==void 0)throw Error("Current directory does already exist.");if(!t&&n!==2&&o===void 0)throw Error("Parent directory must exist");if(t&&n!==2&&o===void 0){const d=i.substr(i.indexOf("/",1));await this.mkdir({path:d,directory:e.directory,recursive:t})}const c=Date.now(),a={path:r,folder:i,type:"directory",size:0,ctime:c,mtime:c};await this.dbRequest("put",[a])}async rmdir(e){const{path:r,directory:t,recursive:i}=e,n=this.getPath(t,r),o=await this.dbRequest("get",[n]);if(o===void 0)throw Error("Folder does not exist.");if(o.type!=="directory")throw Error("Requested path is not a directory");const s=await this.readdir({path:r,directory:t});if(s.files.length!==0&&!i)throw Error("Folder is not empty");for(const c of s.files){const a=`${r}/${c.name}`;(await this.stat({path:a,directory:t})).type==="file"?await this.deleteFile({path:a,directory:t}):await this.rmdir({path:a,directory:t,recursive:i})}await this.dbRequest("delete",[n])}async readdir(e){const r=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[r]);if(e.path!==""&&t===void 0)throw Error("Folder does not exist.");const i=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(r)]);return{files:await Promise.all(i.map(async o=>{let s=await this.dbRequest("get",[o]);return s===void 0&&(s=await this.dbRequest("get",[o+"/"])),{name:o.substring(r.length+1),type:s.type,size:s.size,ctime:s.ctime,mtime:s.mtime,uri:s.path}}))}}async getUri(e){const r=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[r]);return t===void 0&&(t=await this.dbRequest("get",[r+"/"])),{uri:(t==null?void 0:t.path)||r}}async stat(e){const r=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[r]);if(t===void 0&&(t=await this.dbRequest("get",[r+"/"])),t===void 0)throw Error("Entry does not exist.");return{name:t.path.substring(r.length+1),type:t.type,size:t.size,ctime:t.ctime,mtime:t.mtime,uri:t.path}}async rename(e){await this._copy(e,!0)}async copy(e){return this._copy(e,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(e,r=!1){let{toDirectory:t}=e;const{to:i,from:n,directory:o}=e;if(!i||!n)throw Error("Both to and from must be provided");t||(t=o);const s=this.getPath(o,n),c=this.getPath(t,i);if(s===c)return{uri:c};if(R(s,c))throw Error("To path cannot contain the from path");let a;try{a=await this.stat({path:i,directory:t})}catch{const l=i.split("/");l.pop();const p=l.join("/");if(l.length>0&&(await this.stat({path:p,directory:t})).type!=="directory")throw new Error("Parent directory of the to path is a file")}if(a&&a.type==="directory")throw new Error("Cannot overwrite a directory with a file");const d=await this.stat({path:n,directory:o}),h=async(u,l,p)=>{const y=this.getPath(t,u),w=await this.dbRequest("get",[y]);w.ctime=l,w.mtime=p,await this.dbRequest("put",[w])},f=d.ctime?d.ctime:Date.now();switch(d.type){case"file":{const u=await this.readFile({path:n,directory:o});r&&await this.deleteFile({path:n,directory:o});let l;!(u.data instanceof Blob)&&!this.isBase64String(u.data)&&(l=E.UTF8);const p=await this.writeFile({path:i,directory:t,data:u.data,encoding:l});return r&&await h(i,f,d.mtime),p}case"directory":{if(a)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:i,directory:t,recursive:!1}),r&&await h(i,f,d.mtime)}catch{}const u=(await this.readdir({path:n,directory:o})).files;for(const l of u)await this._copy({from:`${n}/${l.name}`,to:`${i}/${l.name}`,directory:o,toDirectory:t},r);r&&await this.rmdir({path:n,directory:o})}}return{uri:c}}isBase64String(e){try{return btoa(atob(e))==e}catch{return!1}}}b._debug=!0;export{b as FilesystemWeb};
